# **Известные недостатки и сомнения по решению**
1. `DynamicComponen` + `ComponentType` - логически связаны один к одному, но на уровне кода гарантий этого нет. Гарантии можно реализовать через шаблоны, но шаблонная магия на мой взгляд сложно воспринимается. Поэтому для внешнего пользователя гарантия предоставляется через класс EntityBuilder.
2. Когда компонентов будет слишком много то `DynamicComponen` и `ComponentType` станут огромными. Тогда можно на группы разбить.
3. `virtual uint32_t Apply(uint32_t tick, std::vector<std::shared_ptr<Entity>>& entities) const = 0;` Возвращаемый тип возможно выглядит как костыль.
Но с другой стороны тут можно возвращать структуру с какой-то статистикой и метриками для каждой систем.
4. В коде есть места которые работают за O(N^2) - это можно оптимизировать если помечать координаты на карте, и искать ближайших войнов по радиусу атаки. Еще вариант сразу поддерживать связь UnitID -> "список ближайших" и поддерживать актуальность через `Observer`. Но выглядит, что это будет большой и сложный код.
5. Я отказался от сущности карты. Возможно, с появлением новых фич, придется реализовать карту, и для оптимизации будет полезно.
6. Не очень хорошо что логгирование проросло в сущность `Game`. Но тут у нас логически два типа эвентов: те которые порождены инициализацией через скрипт и те которые происходят в момент обработки компонент. В целом, выглядит не критично.
