# **Известные недостатки и сомнения по решению**
1. Сделано очень большое допущение, что *атака* всегда приоритетнее чем *движение* (для всех примеров в ТЗ это так), но в теории может быть юнит который наносит удар, если нет противников в заданном радиусе. 
2. `DynamicComponent` + `ComponentType` - логически связаны один к одному, но на уровне кода гарантий этого нет. Гарантии можно реализовать через шаблоны, но шаблонная магия на мой взгляд сложно воспринимается. Поэтому для внешнего пользователя гарантия предоставляется через класс EntityBuilder.
3. Добавление новых компонентов требует изменений в `Core`, но они выглядят минимальными.   
4. Когда компонентов будет слишком много то `DynamicComponen` и `ComponentType` станут огромными. Тогда можно на группы разбить.
5. `virtual uint32_t Apply(uint32_t tick, std::vector<std::shared_ptr<Entity>>& entities) const = 0;` Возвращаемый тип возможно выглядит как костыль.
Но с другой стороны тут можно возвращать структуру с какой-то статистикой и метриками для каждой систем. Была идея чтобы системы возвращали эвенты, тогда логгирование осталось бы только в `Game` - но выглядит как не нужное усложнение.
6. Возможно, зря добавил метод `virtual bool SkipEntity(const std::shared_ptr<Entity>& entity) const = 0` - потому что могут быть системы которым этот метод не нужен, пример: `bool ScoreSystem::SkipEntity([[maybe_unused]] const std::shared_ptr<Entity>& entity) const`. Однако, это решение позволило в системах оставить только код с бизнес логикой.
7. В коде есть места которые работают за O(N^2) - это можно оптимизировать если помечать координаты на карте, и искать ближайших войнов по радиусу атаки. Еще вариант сразу поддерживать связь UnitID -> "список ближайших" и поддерживать актуальность через `Observer`. Но выглядит, что это будет большой и сложный код.
8. Я отказался от сущности карты. Возможно, с появлением новых фич, придется реализовать карту, и для оптимизации будет полезно.
9. Тег `Dead` - возможно, является ненужным усложнением, но показалось что он добавит читаемости и поддержит расширяемость, если юниты будут умирать не только по здоровью (но в ТЗ этого нет). 
   
Открытым остается вопрос об принципе единственной ответственности для систем. Разные системы могут пересекаться по компонентам.    
Например:   
 - Все не `internal` системы помимо основной бизнес-логики, навешивают компонент `HasActed`.
 - Все системы отвечающие за атаку, вынуждены отвечать за добавление тега `Dead`.
   
Для меня это не выглядит как нарушение SRP, т.к. эти теги передают информацию между системами и их логично размещать рядом с бизнес-логикой.    
Можно эти моменты изолировать, но это будет очень избыточно и повредит читаемости, и скорее всего усложнит расширяемость, потому что `HasActed` и `Dead` будут определяться в отдельном месте, о котором нужно помнить.
   
   
